<html> 
	<head>
		<title>Panzer</title>
		<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.1/jquery.min.js"></script>
		<script>window.jQuery || document.write('<script src="js/jquery-1.9.1.min.js"><\/script>');</script>
		<script src="js/pixi.js"></script>
		<script src="js/Keyboard.js"></script>
		<script src="socket.io.min.js"></script>
		<style>
			body {margin: 0;padding: 0;background-color: #fafafa;}
		</style>
	</head>
	<body>
		<script>
			window.requestAnimationFrame = (function(){
			  return  window.requestAnimationFrame       ||
			          window.webkitRequestAnimationFrame ||
			          window.mozRequestAnimationFrame    ||
			          function( callback ){
			            window.setTimeout(callback, 1000 / 60);
			          };
			})();
			
			var socket = io.connect('http://localhost:8765/');
			socket.on('logged', function (playerID) {
				socket.id = playerID;
			});

			$(window).resize(resize);
			window.onorientationchange = resize;
		   	var w = 800;
		   	var h = 650;
		   	var slideX = w/2;
		   	var slideY = h/2;

			// create an array of assets to load
			var assetsToLoader = ["img/textures2.json"];
			// create a new loader
			loader = new PIXI.AssetLoader(assetsToLoader);
			// use callback
			loader.onComplete = onAssetsLoaded;
			//begin load
			loader.load();
			// create an new instance of a pixi stage
		    var stage = new PIXI.Stage(0xB4FF78);		 
		    // create a renderer instance.
		    var renderer = PIXI.autoDetectRenderer(w, h);
		    // add the renderer view element to the DOM
		    document.body.appendChild(renderer.view);
		    function resize(){
				w = window.innerWidth;
				h = window.innerHeight;

				slideX = w / 2;
				slideY = h / 2;

				renderer.resize(w, h);
				spriteContainer.position.x = slideX;
				spriteContainer.position.y = slideY;
			}
		    // create an empty container
			var spriteContainer = new PIXI.DisplayObjectContainer();
			spriteContainer.position.x = Math.floor(slideX);
			spriteContainer.position.y = Math.floor(slideY);
			spriteContainer.scale = new PIXI.Point(0.5,0.5);
			stage.addChild(spriteContainer);

			function onAssetsLoaded(){
				for (var i = 0; i < backgroundMap.length; i++){
					for (var j = 0; j < backgroundMap[i].length; ++j){
						//console.log(i + ' ' + j);
						var grass = new PIXI.Sprite.fromFrame(BackgroundTiles[backgroundMap[i][j]].img);
						grass.i = i;
						grass.j = j;
						var pos = posForIndex(i, j);
						grass.position = pos;
						spriteContainer.addChild(grass);
					}
				}
				players[socket.id] = new Player(socket.id);
				flags[socket.id] = new Flag(socket.id);
				
				//players['krnx'] = new Player('krnx');
				//flags['krnx'] = new Flag('krnx');

				requestAnimationFrame(mainLoop);
				//spriteContainer.addChild(new PIXI.Text('Hi!'));
			}

			function BackgroundTileProperties (props) {
				for (var prop in props) this[prop] = props[prop];
			}
			BackgroundTileProperties.prototype.fatal = false;
			BackgroundTileProperties.prototype.walkable = true;

			var BackgroundTiles = [];
			BackgroundTiles.push( new BackgroundTileProperties({img:'herba'}) );	//0
			BackgroundTiles.push( new BackgroundTileProperties({img:'water', fatal:true}) );	//1
			BackgroundTiles.push( new BackgroundTileProperties({img:'terra'}) );	//2
			BackgroundTiles.push( new BackgroundTileProperties({img:'herba', walkable:false}) );	//3
			BackgroundTiles.push( new BackgroundTileProperties({img:'water', walkable:false}) );	//4

			//El mapa tendrÃ­a que estar rodeado por tiles non-walkable
			var backgroundMap = [	[3,3,3,3,3,4,3,3,3,3,3,3],
									[3,0,0,0,0,1,0,0,0,2,2,3],
									[3,0,0,0,0,0,1,0,2,2,0,3],
									[3,0,0,0,0,0,1,0,0,0,0,3],
									[3,0,0,0,0,2,2,1,1,0,0,3],
									[3,0,0,0,0,2,0,0,1,0,0,3],
									[3,0,0,2,0,0,0,0,0,1,1,3],
									[3,0,0,2,2,0,0,0,0,0,0,4],
									[3,0,0,0,0,2,0,0,0,0,0,3],
									[3,0,0,0,0,0,0,0,0,0,0,3],
									[3,3,3,3,3,3,3,3,3,3,3,3]	];

			function posForIndex (i,j) {
				return {x:j*59-500, y:i*59-500};
			}
			function getRandomMapPos(){
				console.log('bgl: '+(backgroundMap.length-2));
				console.log('bg0l: '+(backgroundMap[0].length-2));
				return {
					i:(Math.floor(Math.random()*(backgroundMap[0].length-2))+1),
					j:(Math.floor(Math.random()*(backgroundMap.length-2))+1)};
			}
			var keyboard = new KeyboardJS(false);

			var players = {};
			var flags = {};
			var oldKeysCHAR = keyboard.keysCHAR;
			
			function Flag(id){
				this.id = id;
				this.j = players[this.id].j;
				this.i = players[this.id].i;
				console.log(this.i);
				this.generateSprite();
				this.untilTick = 1000/1;
				spriteContainer.addChild(players[this.id].sprite);
			}
			Flag.prototype = {
				generateSprite: function(){
					this.sprite = new PIXI.Sprite.fromFrame('bandera');
					var pos = posForIndex(this.i, this.j);
					this.sprite.position = pos;
					spriteContainer.addChild(this.sprite);
				}
			};

			function Player(id){
				this.id = id;
				this.j = getRandomMapPos().i;
				this.i = getRandomMapPos().j;
				this.generateSprite();
				this.untilTick = 1000/1;
			}
			Player.prototype = {
				generateSprite : function () {
					this.sprite = new PIXI.Sprite.fromFrame('panzer2');
					var pos = posForIndex(this.i, this.j);
					this.sprite.position = pos;
					spriteContainer.addChild(this.sprite);
				},
				logic: function(){
					var oldPosition = {i:this.i, j:this.j};
					this.untilTick -= delta;

					if (keyboard.keysCHAR['W'] && !oldKeysCHAR['W']) this.i -= 1;
					if (keyboard.keysCHAR['S'] && !oldKeysCHAR['S']) this.i += 1;
					if (keyboard.keysCHAR['D'] && !oldKeysCHAR['D']) this.j += 1;
					if (keyboard.keysCHAR['A'] && !oldKeysCHAR['A']) this.j -= 1;

					if(this.untilTick < 0){
						console.log('1 seg.');
						this.untilTick = 6000/1;
					}
					var tile = BackgroundTiles[backgroundMap[this.i][this.j]];
					if(!tile.walkable){
						//console.log('j:'+this.j+', i:'+this.i+' bg:'+backgroundMap[this.i][this.j]);
						this.i = oldPosition.i;
						this.j = oldPosition.j;
						console.log('Nop!');
					}else{
						//Comprovar si hi ha player, bandera o mort
						if (oldPosition.i != this.i || oldPosition.j != this.j) {
							if(this.hitTestPlayer()) {
								this.i = oldPosition.i;
								this.j = oldPosition.j;
							}else{
								this.playerMove();
								if (this.hitTestFlag()){
									spriteContainer.addChild(new PIXI.Text('You win!'));
								}
							}
						}
					}
					var pos = posForIndex(this.i,this.j);
					this.sprite.position.x += (pos.x-this.sprite.position.x)/5;
					this.sprite.position.y += (pos.y-this.sprite.position.y)/5;
				},
				hitTestPlayer: function(){
					for(playerID in players){
						if(players[playerID].id != this.id){
							if(hitTest(this,players[playerID]))	return players[playerID];
						}

					}
				},
				hitTestFlag: function(){
					for(flagID in flags){
						if(flags[flagID].id != this.id){
							if (hitTest(this, flags[flagID])) {
								win = true;
								spriteContainer.removeChild(flags[flagID].sprite);
								spriteContainer.removeChild(players[flagID].sprite);
								return true;
							}
						}
					}
				},
				playerMove: function(){
					socket.emit('playerMove', {j:this.j,i:this.i}); //i,j
				}

			}

			function hitTest(player, objeto){
				if(player.i == objeto.i && player.j == objeto.j)
					return true;
				return false;
			}

			var delta = 0;
			var oldDate =+ new Date();

			

			function mainLoop(){
				var currentDate = +new Date();
				delta = currentDate - oldDate;
				oldDate = currentDate;
				if (delta > 100) delta = 100;

				for(var playerID in players){
					players[playerID].logic();
				}

				oldKeysCHAR = {};
				for (var key in keyboard.keysCHAR) {
					oldKeysCHAR[key] = keyboard.keysCHAR[key];
				}

				requestAnimationFrame(mainLoop);
				renderer.render(stage);
			}

			//sockets[i].emit('gameState', {players:playersPacket, coins:coins});
			//sockets[i].emit('gameState', {players:playersPacket, coins:coins});
			socket.on('gameState', function (packet) { //x,y,vx,vy,playerID
				console.log(packet.id);
				console.log(packet.i);
				console.log(packet.j);
			});
			socket.on('playerChangedDirection', function (newDir) { //x,y,vx,vy,playerID
				console.log('1');
			});
		</script>
	</body>		</script>

</html>